@rendermode InteractiveServer
@page "/Game"
@using SixLabors.ImageSharp
@using SixLabors.ImageSharp.Processing
@using SlideMasters_BlazorApp.Models
@using System.Timers

<PageTitle>Home</PageTitle>

<h1>Image Viewer</h1>

<div class="mb-3">
    <button class="btn btn-primary" @onclick='() => LoadImageData("redToji")'>Load Toji Image</button>
</div>

@if (hasLoaded)
{
    <h4>@secondsRemaining</h4>
}

@if (ImageSource != null)
{
    <div>
        <h3>Image Information</h3>
        <p><strong>Path:</strong> @ImageSource</p>
        @if (ImageWidth > 0 && ImageHeight > 0)
        {
            <p><strong>Resolution:</strong> @ImageWidth x @ImageHeight pixels</p>
        }

        <div style="display: grid; grid-template-columns: repeat(4, 100px); gap: 5px; margin: 5px;">
            @if (GameController.slidingPuzzleBlocks.Count > 0)
            {
                //Draw puzzle grid
                for (int i = 0; i < GameController.slidingPuzzleBlocks.Count; i++)
                {
                    @UpdateBlocks(i);
                }
                //Check win condition
                hasWon = GameController.IsCompleted();
            }
        </div>
    </div>
}


@code
{
    //Public
    public GameController GameController { get; set; } = new GameController();
    public int emptyBlockIndex = 0;
    public bool hasLoaded = false;
    public bool hasWon = false;

    //Private
    private string? ImageSource { get; set; }
    private int ImageWidth { get; set; }
    private int ImageHeight { get; set; }


    private ImageSplitter imageSplitter = new ImageSplitter();
    private int gridWidth = 4;
    private int gridHeight = 4;

    private int secondsRemaining { get; set; }
    private Timer? timer { get; set; }
    
    //Render the blocks as the values change (must be rendered in code)
    private RenderFragment<int> UpdateBlocks => value => __builder =>
    {
        var block = GameController.slidingPuzzleBlocks[value];
        if (block.IsEmptyBlock)
        {
            <img src="@block.DataUri" @onclick="(() => OnClickBlock(value))" alt="Image Block" style="width: 100px; height: 100px;" />
        }
        else
        {
            <img src="@block.DataUri" @onclick="(() =>OnClickBlock(value))" alt="Image Block" style="width: 100px; height: 100px; border: 1px solid black;" />
        }
    };

    //Updates and swaps blocks if the clicked block is adjacent to the empty block
    private void OnClickBlock(int index)
    {
        //the code kept rendering past the count, so this restricts movement to valid blocks
        if (index < GameController.slidingPuzzleBlocks.Count)
        {
            ImageBlock clickedBlock = GameController.slidingPuzzleBlocks[index];

            //Clicking the empty block should do nothing, so we check the other blocks
            if (!clickedBlock.IsEmptyBlock)
            {
                //get orthogonal positions
                bool upCoords = FindImageBlock(clickedBlock.BoardX, clickedBlock.BoardY - 1);
                bool downCoords = FindImageBlock(clickedBlock.BoardX, clickedBlock.BoardY + 1);
                bool leftCoords = FindImageBlock(clickedBlock.BoardX - 1, clickedBlock.BoardY);
                bool rightCoords = FindImageBlock(clickedBlock.BoardX + 1, clickedBlock.BoardY);

                int firstIndex = GetImageBlockIndex(clickedBlock.BoardX, clickedBlock.BoardY);

                if (upCoords)
                {
                    //block above clicked block
                    int secondIndex = GetImageBlockIndex(clickedBlock.BoardX, clickedBlock.BoardY - 1);
                    
                    //if it's empty, swap
                    if (GameController.slidingPuzzleBlocks[secondIndex].IsEmptyBlock)
                    {
                        GameController.SwapBlocks(firstIndex, secondIndex);
                        return;
                    }
                }
                if (downCoords)
                {
                    //block under clicked block
                    int secondIndex = GetImageBlockIndex(clickedBlock.BoardX, clickedBlock.BoardY + 1);
                    
                    //if it's empty, swap
                    if (GameController.slidingPuzzleBlocks[secondIndex].IsEmptyBlock)
                    {
                        GameController.SwapBlocks(firstIndex, secondIndex);
                        return;
                    }
                }
                if (leftCoords)
                {
                    //block to the left of clicked block
                    int secondIndex = GetImageBlockIndex(clickedBlock.BoardX - 1, clickedBlock.BoardY);
                    
                    //if it's empty, swap
                    if (GameController.slidingPuzzleBlocks[secondIndex].IsEmptyBlock)
                    {
                        GameController.SwapBlocks(firstIndex, secondIndex);
                        return;
                    }
                }
                if (rightCoords)
                {
                    //block to the right of clicked block
                    int secondIndex = GetImageBlockIndex(clickedBlock.BoardX + 1, clickedBlock.BoardY);
                    
                    //if it's empty, swap
                    if (GameController.slidingPuzzleBlocks[secondIndex].IsEmptyBlock)
                    {
                        GameController.SwapBlocks(firstIndex, secondIndex);
                        return;
                    }
                }
                //block not found, do not search for empty block
                else
                {
                    return;
                }
            }
        }

    }

    private void LoadImageData(string imageName)
    {
        ImageSource = $"/Images/Static/{imageName}.jpg";

        if (!hasLoaded)
        {
            try
            {
                // Path to the image file on the server
                var filePath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", "Images", "Static", $"{imageName}.jpg");

                if (File.Exists(filePath))
                {
                    var imageInfo = Image.Identify(filePath);
                    if (imageInfo != null)
                    {
                        ImageWidth = imageInfo.Width;
                        ImageHeight = imageInfo.Height;
                    }

                    //We only want to split the image if it exists
                    try
                    {
                        //Split the image to store

                        //for square boards, the amount of blocks needs to be a perfect square
                        //so, for a 4x4 board, we use 4 as the mod for rows and columns and 4^2 is our total amount of squares
                        //we also need to use the image resolution to properly set the image in the correct coordinate

                        var getBlocks = imageSplitter.SplitImage(filePath, (gridHeight * gridWidth));

                        for (int i = 0; i < getBlocks.Count(); i++)
                        {
                            var block = new ImageBlock(getBlocks[i]) { BoardID = i };
                            GameController.slidingPuzzleBlocks.Add(block);
                        }

                        //Remove the last block to allow an empty image to be added
                        emptyBlockIndex = GameController.slidingPuzzleBlocks.Count - 1;
                        GameController.slidingPuzzleBlocks.RemoveAt(emptyBlockIndex);

                        //Shuffle the existing pieces
                        ImageRandomizer.Shuffle<ImageBlock>(ref GameController.slidingPuzzleBlocks);

                        //Get the empty block and create an Image block from it
                        //It is resized to match the existing puzzle block dimensions
                        var emptyBlock = Image.Load(Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", "Images", "Static", "empty_block.png"));
                        emptyBlock.Mutate(context => context.Resize(ImageWidth / gridWidth, ImageHeight / gridHeight));
                        var imgEmptyBlock = new ImageBlock(emptyBlock) { IsEmptyBlock = true, BoardID = emptyBlockIndex };

                        //Add the empty block to the end
                        GameController.slidingPuzzleBlocks.Add(imgEmptyBlock);

                        //update all the blocks to have the proper coords
                        for (int i = 0; i < GameController.slidingPuzzleBlocks.Count; i++)
                        {
                            GameController.slidingPuzzleBlocks[i].BoardX = i % gridWidth;
                            GameController.slidingPuzzleBlocks[i].BoardY = (int)(i / gridWidth);
                        }

                        //Puzzle construction is successful, dont allow players to load the image again
                        hasLoaded = true;
                        StartTimer();
                    }
                    catch (Exception spl)
                    {
                        Console.WriteLine($"Error while splitting image: {spl.Message}");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error reading image resolution: {ex.Message}");
            }
        }
    }

    private bool FindImageBlock(int boardX, int boardY)
    {
        ImageBlock? imgBlock = GameController.slidingPuzzleBlocks.Find(img => img.BoardX == boardX && img.BoardY == boardY);

        return (imgBlock == null) ? false : true;
    }

    private int GetImageBlockIndex(int boardX, int boardY)
    {
        ImageBlock? imgBlock = GameController.slidingPuzzleBlocks.Find(img => img.BoardX == boardX && img.BoardY == boardY);
        return (imgBlock == null) ? -1 : GameController.slidingPuzzleBlocks.IndexOf(imgBlock);
    }

    private void StartTimer()
    {
        secondsRemaining = 60;
        timer = new Timer(1000);
        timer.Elapsed += OnTimedEvent;
        timer.AutoReset = true;
        timer.Enabled = true;
    }

    private void OnTimedEvent(object sender, ElapsedEventArgs e)
    {
        if (secondsRemaining > 0)
        {
            secondsRemaining--;
            InvokeAsync(StateHasChanged);
        }
        else
        {
            //Loop timer indefinitely until full split of home page and "game" page
            timer?.Stop();
            StartTimer();
        }
    }
}
